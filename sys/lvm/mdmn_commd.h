/*
 * Please do not edit this file.
 * It was generated using rpcgen.
 */

#ifndef _MDMN_COMMD_H_RPCGEN
#define	_MDMN_COMMD_H_RPCGEN

#include <rpc/rpc.h>
/*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "License").
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */

/*
 * Copyright 2008 Sun Microsystems, Inc.  All rights reserved.
 * Use is subject to license terms.
 */

#include <sys/types.h>
#include <sys/types32.h>
#include <sys/lvm/md_basic.h>
#include <sys/lvm/mdio.h>
#ifndef _KERNEL
#include <mdiox.h>
#include <meta_basic.h>
extern  bool_t  xdr_md_set_params_t(XDR *xdrs, md_set_params_t *objp);
extern  bool_t  xdr_mp_unit_t(XDR *xdrs, mp_unit_t *objp);
extern  bool_t  xdr_diskaddr_t(XDR *xdrs, diskaddr_t *objp);
extern  bool_t  xdr_md_dev64_t(XDR *xdrs, md_dev64_t *objp);
extern  bool_t  xdr_daddr_t(XDR *xdrs, daddr_t *objp);
extern  bool_t  xdr_daddr32_t(XDR *xdrs, daddr32_t *objp);
#else
#include <sys/lvm/md_mdiox.h>
#endif /* ! _KERNEL */
#define	HANDLER_PARMS md_mn_msg_t *msg, uint_t flag, md_mn_result_t *res
#define	SMGEN_PARMS md_mn_msg_t *msg, md_mn_msg_t **msglist

enum md_mn_msgtype_t {
	MD_MN_MSG_NULL = 0,
	MD_MN_MSG_TEST1 = 0 + 1,
	MD_MN_MSG_TEST2 = 0 + 2,
	MD_MN_MSG_TEST3 = 0 + 3,
	MD_MN_MSG_TEST4 = 0 + 4,
	MD_MN_MSG_TEST5 = 0 + 5,
	MD_MN_MSG_TEST6 = 0 + 6,
	MD_MN_MSG_BC_CMD = 0 + 7,
	MD_MN_MSG_BC_CMD_RETRY = 0 + 8,
	MD_MN_MSG_CLU_CHECK = 0 + 9,
	MD_MN_MSG_CLU_LOCK = 0 + 10,
	MD_MN_MSG_CLU_UNLOCK = 0 + 11,
	MD_MN_MSG_REQUIRE_OWNER = 0 + 12,
	MD_MN_MSG_CHOOSE_OWNER = 0 + 13,
	MD_MN_MSG_CHANGE_OWNER = 0 + 14,
	MD_MN_MSG_SUSPEND_WRITES = 0 + 15,
	MD_MN_MSG_STATE_UPDATE_RESWR = 0 + 16,
	MD_MN_MSG_STATE_UPDATE = 0 + 17,
	MD_MN_MSG_ALLOCATE_HOTSPARE = 0 + 18,
	MD_MN_MSG_RESYNC_STARTING = 0 + 19,
	MD_MN_MSG_RESYNC_NEXT = 0 + 20,
	MD_MN_MSG_RESYNC_FINISH = 0 + 21,
	MD_MN_MSG_RESYNC_PHASE_DONE = 0 + 22,
	MD_MN_MSG_SET_CAP = 0 + 23,
	MD_MN_MSG_VERBOSITY = 0 + 24,
	MD_MN_MSG_MDDB_PARSE = 0 + 25,
	MD_MN_MSG_MDDB_BLOCK = 0 + 26,
	MD_MN_MSG_META_DB_ATTACH = 0 + 27,
	MD_MN_MSG_SM_MDDB_ATTACH = 0 + 28,
	MD_MN_MSG_META_DB_DETACH = 0 + 29,
	MD_MN_MSG_SM_MDDB_DETACH = 0 + 30,
	MD_MN_MSG_META_DB_NEWSIDE = 0 + 31,
	MD_MN_MSG_META_DB_DELSIDE = 0 + 32,
	MD_MN_MSG_META_MD_ADDSIDE = 0 + 33,
	MD_MN_MSG_META_MD_DELSIDE = 0 + 34,
	MD_MN_MSG_MDDB_OPTRECERR = 0 + 35,
	MD_MN_MSG_ABORT = 0 + 36,
	MD_MN_MSG_STATE_UPDATE_RESWR2 = 0 + 37,
	MD_MN_MSG_STATE_UPDATE2 = 0 + 38,
	MD_MN_MSG_ALLOCATE_HOTSPARE2 = 0 + 39,
	MD_MN_MSG_IOCSET = 0 + 40,
	MD_MN_MSG_SP_SETSTAT = 0 + 41,
	MD_MN_MSG_ADDKEYNAME = 0 + 42,
	MD_MN_MSG_DELKEYNAME = 0 + 43,
	MD_MN_MSG_GET_TSTATE = 0 + 44,
	MD_MN_MSG_GET_MIRROR_STATE = 0 + 45,
	MD_MN_MSG_SP_SETSTAT2 = 0 + 46,
	MD_MN_MSG_SETSYNC = 0 + 47,
	MD_MN_MSG_POKE_HOTSPARES = 0 + 48,
	MD_MN_MSG_ADDMDNAME = 0 + 49,
	MD_MN_MSG_RR_DIRTY = 0 + 50,
	MD_MN_MSG_RR_CLEAN = 0 + 51,
	MD_MN_NMESSAGES = 0 + 52
};
typedef enum md_mn_msgtype_t md_mn_msgtype_t;

enum md_mn_msgclass_t {
	MD_MSG_CLASS0 = 0,
	MD_MSG_CLASS1 = 0 + 1,
	MD_MSG_CLASS2 = 0 + 2,
	MD_MSG_CLASS3 = 0 + 3,
	MD_MSG_CLASS4 = 0 + 4,
	MD_MSG_CLASS5 = 0 + 5,
	MD_MSG_CLASS6 = 0 + 6,
	MD_MSG_CLASS7 = 0 + 7,
	MD_MN_NCLASSES = 0 + 8
};
typedef enum md_mn_msgclass_t md_mn_msgclass_t;
/*
 * The following are needed for things like suspend and resume when the
 * operation is to be applied to all classes / all sets.
 */
#define	MD_COMM_ALL_CLASSES MD_MSG_CLASS0
#define	MD_COMM_ALL_SETS 0

struct md_mn_msg_stch_t {
	minor_t msg_stch_mnum;
	int msg_stch_sm;
	int msg_stch_comp;
	int msg_stch_new_state;
	mddb_recid_t msg_stch_hs_id;
};
typedef struct md_mn_msg_stch_t md_mn_msg_stch_t;

struct md_mn_msg_suspwr_t {
	minor_t msg_suspwr_mnum;
};
typedef struct md_mn_msg_suspwr_t md_mn_msg_suspwr_t;

struct md_mn_msg_chooseid_t {
	minor_t msg_chooseid_mnum;
	int msg_chooseid_rcnt;
	int msg_chooseid_set_node;
};
typedef struct md_mn_msg_chooseid_t md_mn_msg_chooseid_t;

struct md_mn_msg_chowner_t {
	minor_t msg_chowner_mnum;
	int msg_chowner_nodeid;
};
typedef struct md_mn_msg_chowner_t md_mn_msg_chowner_t;

struct md_mn_msg_setcap_t {
	char msg_setcap_driver[MD_DRIVERNAMELEN];
	minor_t msg_setcap_mnum;
	u_int msg_setcap_set;
};
typedef struct md_mn_msg_setcap_t md_mn_msg_setcap_t;

struct md_mn_verbose_t {
	set_t mmv_setno;
	md_mn_msgclass_t mmv_class;
	u_int mmv_what;
};
typedef struct md_mn_verbose_t md_mn_verbose_t;
/* turn off everything */
#define	MD_MMV_NULL 		0x00000000
/* initialization of nodes / rpc clients */
#define	MD_MMV_INIT		0x00000001
/* mdmn_send_svc_1 related / early stage */
#define	MD_MMV_SEND		0x00000002
/* mdmn_work_svc_1 stuff on master */
#define	MD_MMV_WORK		0x00000004
/* mdmn_master_process_msg stuff */
#define	MD_MMV_PROC_M		0x00000008
/* mdmn_slave_process_msg stuff */
#define	MD_MMV_PROC_S		0x00000010
/* wakeup_master  */
#define	MD_MMV_WAKE_M		0x00000020
/* wakeup_initiator */
#define	MD_MMV_WAKE_I		0x00000040
/* Misc stuff*/
#define	MD_MMV_MISC		0x00000080
/* turn on everything */
#define	MD_MMV_ALL		0x0000ffff	
/* write to syslog instead of output file, for critical messages */
#define	MD_MMV_SYSLOG		0x10000000	
/* enable timestamps */
#define	MD_MMV_TIMESTAMP	0x20000000

struct md_mn_msg_allochsp_t {
	minor_t msg_allochsp_mnum;
	int msg_allochsp_sm;
	int msg_allochsp_comp;
	mddb_recid_t msg_allochsp_hs_id;
};
typedef struct md_mn_msg_allochsp_t md_mn_msg_allochsp_t;

struct md_mn_msg_resync_t {
	minor_t msg_resync_mnum;
	int msg_resync_type;
	diskaddr_t msg_resync_start;
	diskaddr_t msg_resync_rsize;
	diskaddr_t msg_resync_done;
	diskaddr_t msg_resync_2_do;
	int msg_originator;
	int msg_resync_flags;
	sm_state_t msg_sm_state[NMIRROR];
	sm_flags_t msg_sm_flags[NMIRROR];
};
typedef struct md_mn_msg_resync_t md_mn_msg_resync_t;
#define	MD_MSGF_DEFAULT_FLAGS		0x00000000

struct md_mn_msg_mddb_block_t {
	int msg_block_flags;
};
typedef struct md_mn_msg_mddb_block_t md_mn_msg_mddb_block_t;

struct md_mn_msg_mddb_parse_t {
	int msg_parse_flags;
	int msg_lb_flags[50];
};
typedef struct md_mn_msg_mddb_parse_t md_mn_msg_mddb_parse_t;

struct md_mn_msg_meta_db_attach_t {
	md_dev64_t msg_l_dev;
	int msg_cnt;
	int msg_dbsize;
	char msg_dname[16];
	md_splitname msg_splitname;
	u_int msg_options;
	char msg_devid[1];
};
typedef struct md_mn_msg_meta_db_attach_t md_mn_msg_meta_db_attach_t;

struct md_mn_msg_meta_db_detach_t {
	md_splitname msg_splitname;
	char msg_devid[1];
};
typedef struct md_mn_msg_meta_db_detach_t md_mn_msg_meta_db_detach_t;

struct md_mn_msg_meta_db_newside_t {
	md_dev64_t msg_l_dev;
	daddr_t msg_blkno;
	side_t msg_sideno;
	minor_t msg_mnum;
	char msg_dname[16];
	md_splitname msg_splitname;
	char msg_devid[1];
};
typedef struct md_mn_msg_meta_db_newside_t md_mn_msg_meta_db_newside_t;

struct md_mn_msg_meta_db_delside_t {
	md_dev64_t msg_l_dev;
	daddr_t msg_blkno;
	side_t msg_sideno;
	char msg_devid[1];
};
typedef struct md_mn_msg_meta_db_delside_t md_mn_msg_meta_db_delside_t;

struct md_mn_msg_meta_md_addside_t {
	side_t msg_sideno;
	side_t msg_otherside;
};
typedef struct md_mn_msg_meta_md_addside_t md_mn_msg_meta_md_addside_t;

struct md_mn_msg_meta_md_delside_t {
	side_t msg_sideno;
};
typedef struct md_mn_msg_meta_md_delside_t md_mn_msg_meta_md_delside_t;

struct md_mn_msg_mddb_optrecerr_t {
	md_replica_recerr_t msg_recerr[2];
};
typedef struct md_mn_msg_mddb_optrecerr_t md_mn_msg_mddb_optrecerr_t;

struct md_mn_msg_iocset_t {
	md_set_params_t iocset_params;
	mp_unit_t unit;
};
typedef struct md_mn_msg_iocset_t md_mn_msg_iocset_t;

struct md_mn_msg_sp_setstat_t {
	minor_t sp_setstat_mnum;
	int sp_setstat_status;
};
typedef struct md_mn_msg_sp_setstat_t md_mn_msg_sp_setstat_t;

struct md_mn_msg_addkeyname_t {
	set_t addkeyname_setno;
	char addkeyname_name[1];
};
typedef struct md_mn_msg_addkeyname_t md_mn_msg_addkeyname_t;

struct md_mn_msg_addmdname_t {
	set_t addmdname_setno;
	char addmdname_name[1];
};
typedef struct md_mn_msg_addmdname_t md_mn_msg_addmdname_t;

struct md_mn_msg_delkeyname_t {
	md_dev64_t delkeyname_dev;
	set_t delkeyname_setno;
	mdkey_t delkeyname_key;
};
typedef struct md_mn_msg_delkeyname_t md_mn_msg_delkeyname_t;

struct md_mn_msg_gettstate_t {
	md_dev64_t gettstate_dev;
};
typedef struct md_mn_msg_gettstate_t md_mn_msg_gettstate_t;

struct md_mn_msg_mir_state_t {
	minor_t mir_state_mnum;
};
typedef struct md_mn_msg_mir_state_t md_mn_msg_mir_state_t;

struct md_mn_msg_mir_state_res_t {
	sm_state_t sm_state[NMIRROR];
	sm_flags_t sm_flags[NMIRROR];
	u_int mir_tstate;
};
typedef struct md_mn_msg_mir_state_res_t md_mn_msg_mir_state_res_t;

struct md_mn_msg_setsync_t {
	minor_t setsync_mnum;
	md_riflags_t setsync_flags;
	diskaddr_t setsync_copysize;
};
typedef struct md_mn_msg_setsync_t md_mn_msg_setsync_t;

struct md_mn_msg_pokehsp_t {
	minor_t pokehsp_setno;
};
typedef struct md_mn_msg_pokehsp_t md_mn_msg_pokehsp_t;

struct md_mn_msg_rr_dirty_t {
	minor_t rr_mnum;
	int rr_nodeid;
	u_int rr_range;
};
typedef struct md_mn_msg_rr_dirty_t md_mn_msg_rr_dirty_t;
#define	MDMN_MSG_RR_CLEAN_DATA_MAX_BYTES	\
		    ((MDMN_MAX_KMSG_DATA) - \
		    sizeof (struct md_mn_msg_rr_clean_t))
#define	MDMN_MSG_RR_CLEAN_SIZE_DATA(x)		\
		    (sizeof (struct md_mn_msg_rr_clean_t) + (x))
#define	MDMN_MSG_RR_CLEAN_MSG_SIZE(x)		\
		    (sizeof (struct md_mn_msg_rr_clean_t) \
		    + MDMN_MSG_RR_CLEAN_DATA_BYTES(x))
#define	MDMN_MSG_RR_CLEAN_DATA(x)		\
		    ((unsigned char *)(x) + \
		    sizeof (struct md_mn_msg_rr_clean_t))
#define	MDMN_MSG_RR_CLEAN_START_BIT(x)	((x)->rr_start_size >> 16)
#define	MDMN_MSG_RR_CLEAN_DATA_BYTES(x)	((x)->rr_start_size & 0xffff)
#define	MDMN_MSG_RR_CLEAN_START_SIZE_SET(x, start, size) \
			((x)->rr_start_size = (start << 16) | size)

struct md_mn_msg_rr_clean_t {
	md_mn_nodeid_t rr_nodeid;
	u_int rr_mnum;
	u_int rr_start_size;
};
typedef struct md_mn_msg_rr_clean_t md_mn_msg_rr_clean_t;
#define	MD_MSGF_NO_LOG			0x00000001
#define	MD_MSGF_NO_BCAST		0x00000002
#define	MD_MSGF_STOP_ON_ERROR		0x00000004
#define	MD_MSGF_REPLAY_MSG		0x00000008
#define	MD_MSGF_OVERRIDE_SUSPEND	0x00000010
#define	MD_MSGF_ON_MASTER		0x00000020
#define	MD_MSGF_ON_SLAVE		0x00000040
#define	MD_MSGF_ON_INITIATOR		0x00000080
#define	MD_MSGF_LOCAL_ONLY		0x00000100
#define	MD_MSGF_FAIL_ON_SUSPEND		0x00000200
#define	MD_MSGF_NO_MCT			0x00000400
#define	MD_MSGF_PANIC_WHEN_INCONSISTENT	0x00000800
#define	MD_MSGF_BLK_SIGNAL		0x00001000
#define	MD_MSGF_KSEND_NORETRY		0x00002000
#define	MD_MSGF_DIRECTED		0x00004000
#define	MD_MSGF_VERBOSE			0x10000000
#define	MD_MSGF_VERBOSE_2		0x20000000
#define	MD_MSGF_INHERIT_BITS		\
			MD_MSGF_REPLAY_MSG | MD_MSGF_OVERRIDE_SUSPEND
/* maximum number of nodes in cluster (not in diskset) */
#define	NNODES MD_MNMAXSIDES

struct md_mn_msgid_t {
	uint64_t mid_time;
	md_mn_nodeid_t mid_nid;
	md_mn_msgclass_t mid_oclass;
	uint8_t mid_smid;
	uint8_t mid_spare[15];
};
typedef struct md_mn_msgid_t md_mn_msgid_t;
#define MD_NULL_MSGID (md_mn_msgid_t *)NULL

/* macros to handle msgid's */
#define	MSGID_COPY(from, to) {				\
			(to)->mid_nid = (from)->mid_nid;	\
			(to)->mid_smid = (from)->mid_smid;	\
			(to)->mid_oclass = (from)->mid_oclass;	\
			(to)->mid_time = (from)->mid_time;	\
		}

#define	MSGID_CMP(a, b) 				\
			(((a)->mid_nid == (b)->mid_nid) &&	\
			((a)->mid_smid == (b)->mid_smid) &&	\
			((a)->mid_time == (b)->mid_time))

#define	MSGID_ELEMS(mid) (mid).mid_nid, (mid).mid_time, (mid).mid_smid

struct md_mn_msg_t {
	md_mn_msgid_t msg_msgid;
	md_mn_nodeid_t msg_sender;
	u_int msg_flags;
	set_t msg_setno;
	md_mn_msgtype_t msg_type;
	md_mn_nodeid_t msg_recipient;
	char msg_spare[28];
	struct {
		u_int msg_event_len;
		char *msg_event_val;
	} msg_event;
};
typedef struct md_mn_msg_t md_mn_msg_t;
#define	msg_event_data	msg_event.msg_event_val
#define	msg_event_size	msg_event.msg_event_len

#define	MD_MN_MSG_LEN(msg)	((msg)->msg_event_size +\
							sizeof (md_mn_msg_t))
#define	MD_MN_MSG_MAXDATALEN	1024

struct md_mn_msg_od_t {
	md_mn_msgid_t msg_msgid;
	md_mn_nodeid_t msg_sender;
	uint32_t msg_flags;
	set_t msg_setno;
	md_mn_msgtype_t msg_type;
	md_mn_nodeid_t msg_recipient;
	char msg_spare[28];
	uint32_t msg_ev_len;
	char msg_ev_val[MD_MN_MSG_MAXDATALEN];
};
typedef struct md_mn_msg_od_t md_mn_msg_od_t;

#define	msg_od_event_data	msg_ev_val
#define	msg_od_event_size	msg_ev_len
#define	MDMN_MAX_KMSG_DATA	256

struct md_mn_kmsg_t {
	md_mn_msgid_t kmsg_msgid;
	u_int kmsg_flags;
	set_t kmsg_setno;
	md_mn_msgtype_t kmsg_type;
	md_mn_nodeid_t kmsg_recipient;
	int kmsg_size;
	char kmsg_data[MDMN_MAX_KMSG_DATA];
};
typedef struct md_mn_kmsg_t md_mn_kmsg_t;

struct md_mn_result_t {
	md_mn_msgid_t mmr_msgid;
	md_mn_msgtype_t mmr_msgtype;
	set_t mmr_setno;
	u_int mmr_flags;
	md_mn_nodeid_t mmr_sender;
	md_mn_nodeid_t mmr_failing_node;
	int mmr_comm_state;
	int mmr_exitval;
	md_error_t mmr_ep;
	struct {
		u_int mmr_output_len;
		char *mmr_output_val;
	} mmr_output;
	struct {
		u_int mmr_error_len;
		char *mmr_error_val;
	} mmr_error;
};
typedef struct md_mn_result_t md_mn_result_t;
#define	MDMN_MAX_KRES_DATA	256

struct md_mn_kresult_t {
	md_mn_msgtype_t kmmr_msgtype;
	u_int kmmr_flags;
	int kmmr_comm_state;
	md_mn_nodeid_t kmmr_failing_node;
	int kmmr_exitval;
	int kmmr_res_size;
	char kmmr_res_data[MDMN_MAX_KRES_DATA];
};
typedef struct md_mn_kresult_t md_mn_kresult_t;

enum md_mn_retval_t {
	MDMNE_NULL = 0,
	MDMNE_ACK = 0 + 1,
	MDMNE_CLASS_BUSY = 0 + 2,
	MDMNE_RPC_FAIL = 0 + 3,
	MDMNE_THR_CREATE_FAIL = 0 + 4,
	MDMNE_NO_HANDLER = 0 + 5,
	MDMNE_LOG_FAIL = 0 + 6,
	MDMNE_CANNOT_CONNECT = 0 + 7,
	MDMNE_NO_WAKEUP_ENTRY = 0 + 8,
	MDMNE_NOT_JOINED = 0 + 9,
	MDMNE_HANDLER_FAILED = 0 + 10,
	MDMNE_EINVAL = 0 + 11,
	MDMNE_SUSPENDED = 0 + 12,
	MDMNE_CLASS_LOCKED = 0 + 13,
	MDMNE_TIMEOUT = 0 + 14,
	MDMNE_SET_NOT_DRAINED = 0 + 15,
	MDMNE_ABORT = 0 + 16,
	MDMNE_IGNORE_NODE = 0 + 17
};
typedef enum md_mn_retval_t md_mn_retval_t;

#define	MDMN_KSEND_MSG_OK(rv, kres)		\
	(((rv) == 0) && (((kres)->kmmr_exitval == 0) && \
	 (((kres)->kmmr_comm_state == MDMNE_ACK) || \
	  (!md_mn_is_commd_present() && \
	   ((kres)->kmmr_comm_state == MDMNE_RPC_FAIL)))))


#define	mmr_out		mmr_output.mmr_output_val
#define	mmr_out_size	mmr_output.mmr_output_len
#define	mmr_err		mmr_error.mmr_error_val
#define	mmr_err_size	mmr_error.mmr_error_len


extern void mdmn_master_process_msg(md_mn_msg_t *);
extern void mdmn_slave_process_msg(md_mn_msg_t *);

struct md_mn_set_and_class_t {
	set_t msc_set;
	md_mn_msgclass_t msc_class;
	u_int msc_flags;
};
typedef struct md_mn_set_and_class_t md_mn_set_and_class_t;
/* possible values for msc_flags above */
#define	MD_MSCF_NO_FLAGS		0x0000
#define	MD_MSCF_DONT_RESUME_CLASS1	0x0001

struct md_mn_type_and_lock_t {
	md_mn_msgtype_t mmtl_type;
	u_int mmtl_lock;
};
typedef struct md_mn_type_and_lock_t md_mn_type_and_lock_t;
/* possible values for mmtl_flags above */
#define	MMTL_UNLOCK		0x0000
#define	MMTL_LOCK		0x0001
/* Currently not used, but thinkable extensions */
#define	MMTL_LOCK_ON_INITIATOR	0x0002
#define	MMTL_LOCK_ON_MASTER	0x0004
#define	MMTL_LOCK_ON_SLAVE	0x0008
#define	MMTL_LOCK_ONE_TIME_ONLY	0x0010

#define	MDMN_COMMD	100422
#define	TWO	2
#define	mdmn_send	1
extern  md_mn_result_t * mdmn_send_2();
#define	mdmn_work	2
extern  int * mdmn_work_2();
#define	mdmn_wakeup_initiator	3
extern  int * mdmn_wakeup_initiator_2();
#define	mdmn_wakeup_master	4
extern  int * mdmn_wakeup_master_2();
#define	mdmn_comm_lock	5
extern  int * mdmn_comm_lock_2();
#define	mdmn_comm_unlock	6
extern  int * mdmn_comm_unlock_2();
#define	mdmn_comm_suspend	7
extern  int * mdmn_comm_suspend_2();
#define	mdmn_comm_resume	8
extern  int * mdmn_comm_resume_2();
#define	mdmn_comm_reinit_set	9
extern  int * mdmn_comm_reinit_set_2();
#define	mdmn_comm_msglock	10
extern  int * mdmn_comm_msglock_2();
extern int mdmn_commd_2_freeresult();

/* the xdr functions */
extern bool_t xdr_md_mn_msgtype_t();
extern bool_t xdr_md_mn_msgclass_t();
extern bool_t xdr_md_mn_msg_stch_t();
extern bool_t xdr_md_mn_msg_suspwr_t();
extern bool_t xdr_md_mn_msg_chooseid_t();
extern bool_t xdr_md_mn_msg_chowner_t();
extern bool_t xdr_md_mn_msg_setcap_t();
extern bool_t xdr_md_mn_verbose_t();
extern bool_t xdr_md_mn_msg_allochsp_t();
extern bool_t xdr_md_mn_msg_resync_t();
extern bool_t xdr_md_mn_msg_mddb_block_t();
extern bool_t xdr_md_mn_msg_mddb_parse_t();
extern bool_t xdr_md_mn_msg_meta_db_attach_t();
extern bool_t xdr_md_mn_msg_meta_db_detach_t();
extern bool_t xdr_md_mn_msg_meta_db_newside_t();
extern bool_t xdr_md_mn_msg_meta_db_delside_t();
extern bool_t xdr_md_mn_msg_meta_md_addside_t();
extern bool_t xdr_md_mn_msg_meta_md_delside_t();
extern bool_t xdr_md_mn_msg_mddb_optrecerr_t();
extern bool_t xdr_md_mn_msg_iocset_t();
extern bool_t xdr_md_mn_msg_sp_setstat_t();
extern bool_t xdr_md_mn_msg_addkeyname_t();
extern bool_t xdr_md_mn_msg_addmdname_t();
extern bool_t xdr_md_mn_msg_delkeyname_t();
extern bool_t xdr_md_mn_msg_gettstate_t();
extern bool_t xdr_md_mn_msg_mir_state_t();
extern bool_t xdr_md_mn_msg_mir_state_res_t();
extern bool_t xdr_md_mn_msg_setsync_t();
extern bool_t xdr_md_mn_msg_pokehsp_t();
extern bool_t xdr_md_mn_msg_rr_dirty_t();
extern bool_t xdr_md_mn_msg_rr_clean_t();
extern bool_t xdr_md_mn_msgid_t();
extern bool_t xdr_md_mn_msg_t();
extern bool_t xdr_md_mn_msg_od_t();
extern bool_t xdr_md_mn_kmsg_t();
extern bool_t xdr_md_mn_result_t();
extern bool_t xdr_md_mn_kresult_t();
extern bool_t xdr_md_mn_retval_t();
extern bool_t xdr_md_mn_set_and_class_t();
extern bool_t xdr_md_mn_type_and_lock_t();

#endif /* !_MDMN_COMMD_H_RPCGEN */
